
https://www.youtube.com/watch?v=Xi3ioi1213k&list=PLhqasd25bl-hamUHgiK7ooKBjt0y7L5XS&index=3
-> There are several kinds of Cond条件码 (33:37)
  http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204j/Chdhcfbc.html
  -It occupies 4 bits (位)  (33:55)
  -EQ used to determine (判断) Z flag 标志位 ==1 (set 置1 ) (34:02)
  -NE used to determine (判断) Z flag 标志位 ==0 (clear 置0) (34:09)
  -Have to know the concept. Detail can be learned when needeed (34:58)
  -However, if your job relates the development 开发 of ARM assembly 汇编, you need to know the detail (35:06)
  -Use this to do the bubble sort (冒泡排序) (35:23)
    -Whwen we should exchange, when we don't exchenage (35:33) 
    -It can be used as an assighment (35:41)
    -
->Difference between Cond条件码 and s码 (35:52)
    -The working time (工作时间点) is different (36:00)
    -One (Cond条件码) is done before (前) the insturction set (指令) of branch being executed (36:02)
      -b is for branch (跳转) and eq is 条件码 (Condition code) (36:50)
      -before branching, I need to see if condition (条件) of beq is met (成立) or not(36:55)
      -Once the Cond条件码 is met (成立), (37:00) I will do the branch (跳转) (36:59). Otherwise I won't jump (37:03)
      -The determination of Cond条件码 is done BEFORE executing the instruction set (指令) of  branch (37:09)
    -The other (s码) is done after(后) the intruction set (指令) of branch being executed (37:07).
      - After addition (加法)/subtraction such as ->add r0,r1,#0x55 in line 136 of "Chapter1_sec3_A.c" (37:14), it may cause carry (进位) as 1 (37:16)
        so the flag (标志) in CPSR has to be set (置位) as 1 (37:21) after the adds/subs
    -Therefore, 指令执行前判段条件码是否成立
                  -it may affect both C and V if carry and overflow both occur OR only Carry if only carry occurs(38:40)
       -        指令执行厚，跟据s码的设置,影响CPSR register (寄存器)'s assciated 相关 flags 标志位 (37:58)
    -software crack (软件破解)->(39:02) It will be really important (39:05)
      -a softeware program (程序) in binary (二进制) is executed (执行) (39:20). In windows (.exe) in Linux (.elf) (39:32)
      -Software may ask you to enter the register info/number (39:45)
                    -res=identity_authorization()  (40:23)
                     if(result>0)
                     {
                       //intiate_program
                     }else{
                       //notifiy user to re-enter again
                     }
     -assembler->change the assembly code to 0's and 1's
     -Diassembler->change to 0's and 1's to assembly (41:28)
     -Brief concept of diassembler (42:37)(44:17)    
->gcc kernel.c -g -o app
   -"-g" has the meaning of "adding comment" for C lanuage (47:09)
   - "file app" will tell you this is a ELF file (47:20)
   - "objdump -dSsx app > file"
   - "vi file" the "file" becomes the result of diassemler (47:48)
       -you get the binary code in hex with its associated diassembly code (48:37)
   - without "-g", you can't see anything in C lanuage (49:26)
   -
->(50:00) Comparing ARM and x86
  -x86's byte code of instruction set's width is not fixed (50:10). Can be 2/3/4 bytes 
  -Install cross compiler(交叉编译程器) in linux/windows (50:49) enviroment (50:57)
  -you need to install "arm-linux-gcc" (51:23)
  -vi t.c   (51:58)
  #include<stdio.h>
  
  void foo(int a)
  {
    while(a--)
      printf("hello\n");
  }
  int main(void)
  {
    printf("hey\n");
    foo(3);
    printf("world\n");
    return 0;
  } //(52:50)
     
       
->file a.out is based on x86 (53:06) 
->need to type "arm-linux-gcc t.c -o arm.a.out" (53:21)
->type file "arm.a.out", it will tells us this is for arm cpu (53:41)
->if we type "arm.a.out" can't be executed (53:42)
->type "arm-linux-objdump -dSsx arm.a.out > file" (54:21)
->@ 8400(address) e92d4800(machine code 机器指令 or 机器码) push {fp,blr}(assembly code 汇编码 )  (54:53)
->Each machine code 机器码 consists of 4 byte (字节) or (32bit 位)(55:08)
  mov r0,#3 //move 3 to r0
  bl 83b0<foo> //
->Where is the function of foo? It is in the address of 83b0 (55:35)
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->
->

